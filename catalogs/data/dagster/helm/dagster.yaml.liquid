{% raw %}
{% capture imports_dagster_key %}dagster-{{ configuration.cluster }}{% endcapture %}

global:
  serviceAccountName: {{ imports[imports_dagster_key].service_account_name }}

dagsterWebserver:
  annotations:
    {% if configuration.cloud == 'azure' %}
    azure.workload.identity/client-id: {{ imports[imports_dagster_key].blobstore_client_id }}
    {% endif %}
    security.plural.sh/oauth-env-secret: dagster-proxy-config
    {% if configuration["basicAuth"] %}
    security.plural.sh/htpasswd-secret: httpaswd-users
    {% endif %}
  labels:
    security.plural.sh/inject-oauth-sidecar: "true"
    azure.workload.identity/use: "true"
  {% if configuration.cloud == 'aws' %}
  envSecrets:
    - name: dagster-env
  {% endif %}

postgresql:
  enabled: false
  postgresqlHost: {{ imports[imports_dagster_key].postgres_host }}
  postgresqlUsername: dagster
  postgresqlPassword: {{ imports[imports_dagster_key].postgres_password }}
  postgresqlDatabase: dagster
  postgresqlParams:
    sslmode: require

{% if configuration.cloud == 'aws' %}
computeLogManager:
  type: S3ComputeLogManager
  config:
    s3ComputeLogManager:
      bucket: {{ configuration.bucket }}
{% endif %}

{% if configuration.cloud == 'azure' %}
computeLogManager:
  type: AzureBlobComputeLogManager
  config:
    azureBlobComputeLogManager:
      storageAccount: {{ imports[imports_dagster_key].storage_account_name }}
      container: {{ imports[imports_dagster_key].container_name  }}
      defaultAzureCredential:
        exclude_environment_credential: false
        exclude_managed_identity_credential: true
        exclude_cli_credential: true
        exclude_powershell_credential: true
        exclude_developer_cli_credential: true
        exclude_visual_studio_code_credential: true
        exclude_shared_token_cache_credential: true
        workload_identity_client_id: {{ imports[imports_dagster_key].blobstore_client_id }} # when this actually works, enable it
{% endif %}

{% if configuration.cloud == 'gcp' %}
computeLogManager:
  type: GCSComputeLogManager
  config:
    gcsComputeLogManager:
      bucket: {{ configuration.bucket }}
      # jsonCredentialsEnvvar: ~
{% endif %}

ingress:
  enabled: true
  ingressClassName: nginx
  dagsterWebserver:
    host: {{ configuration.hostname }}
    tls:
      enabled: true
      secretName: dagster-tls
    precedingPaths:
      - path: /.*
        pathType: ImplementationSpecific
        serviceName: dagster-oauth2-proxy
        servicePort: http-oauth
  annotations:
    kubernetes.io/tls-acme: "true"
    cert-manager.io/cluster-issuer: letsencrypt-prod
    # Extend timeout to allow long running queries.
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "300"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "300"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "300"
    nginx.ingress.kubernetes.io/use-regex: "true"

{% if configuration.cloud == 'aws' %}
runLauncher:
  config:
    k8sRunLauncher:
      envSecrets:
        - name: dagster-env
{% endif %}

dagster-user-deployments:
  enabled: true
  deployments:
    - name: "iris-analysis" # set to the name of your deployment
      image:
        repository: "iris_analysis" # set to the name of your Docker image
        # When a tag is not supplied, it will default as the Helm chart version.
        tag: 1 # set to the tag of your Docker image

        # Only change this value if you are following the guide on your
        # local machine. If you are pushing images to a registry,
        # leave the value as Always
        pullPolicy: IfNotPresent

      dagsterApiGrpcArgs:
        - "--python-file"
        - "/iris_analysis/definitions.py"
{% endraw %}
